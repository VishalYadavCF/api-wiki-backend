## API Endpoint Documentation: SSO Authentication Callback

This document provides a comprehensive overview of the `/api/v1/auth/callback/sso` API endpoint, designed for managing user authentication through an external Single Sign-On (SSO) provider.

---

### 1. Endpoint Overview

*   **Endpoint Path:** `/api/v1/auth/callback/sso`
*   **HTTP Method:** `GET`
*   **Consumes:** `application/x-www-form-urlencoded` (via query parameters)
*   **Produces:** `application/json`
*   **Controller Method:** `AuthCallbackController.handleSsoCallback`
*   **Primary Purpose:** This endpoint serves as the callback URL for an external SSO provider (e.g., Google, Okta, Azure AD). Its main function is to receive the authentication response from the SSO provider, validate it, and then establish an internal authenticated session for the user within our application by issuing a secure JSON Web Token (JWT) and relevant session cookies.

### 2. Request and Response

#### Request Details

The endpoint expects specific query parameters to be provided by the external SSO provider as part of the redirect after successful external authentication.

*   **Parameters (Query String):**
    *   `code` (String, Required): An authorization code provided by the SSO server, which is then exchanged for actual access tokens.
    *   `state` (String, Required): A unique, cryptographically secure random string initially sent by our application to the SSO provider. This parameter is returned unmodified and used for Cross-Site Request Forgery (CSRF) protection.
    *   `id_token` (String, Optional): An ID Token provided by the SSO server (common in OpenID Connect flows), containing information about the authenticated user.

#### Success Response Details

Upon successful processing, the endpoint returns a `200 OK` HTTP status code along with a JSON payload, an Authorization header, and several cookies.

*   **HTTP Status Code:** `200 OK`
*   **Payload (JSON):**
    ```json
    {
      "userId": "unique-user-id-from-db",
      "username": "john.doe",
      "email": "john.doe@example.com",
      "roles": ["USER", "ADMIN"],
      "message": "Authentication successful"
    }
    ```
    *   `userId`: The internal unique identifier for the authenticated user.
    *   `username`: The user's display name or login handle.
    *   `email`: The user's primary email address.
    *   `roles`: A list of roles or permissions assigned to the user within the application.
    *   `message`: A confirmation message.
*   **Headers:**
    *   `Authorization`: `Bearer <INTERNAL_JWT>` - Contains the application's internal JWT, which should be used by the client for subsequent authenticated API requests.
*   **Cookies:**
    *   `SESSIONID` (HttpOnly, Secure, SameSite=Lax, Max-Age): A long-lived session cookie essential for maintaining the user's session state.
    *   `XSRF-TOKEN` (Secure, Max-Age): A short-lived cookie containing a token used in conjunction with the `X-XSRF-TOKEN` header for CSRF protection on subsequent requests.

#### Error Response Details

In case of errors, the endpoint will return an appropriate HTTP status code and a standard error JSON payload.

*   **HTTP Status Codes:**
    *   `400 Bad Request`: If required query parameters are missing or invalid (e.g., `code` or `state` are absent or malformed).
    *   `401 Unauthorized`: If the external authentication `code` is invalid, the SSO provider denies the token exchange, or the `id_token` validation fails.
    *   `500 Internal Server Error`: For unexpected server-side issues (e.g., database connection problems, internal service failures, cryptographic errors).
*   **Payload (JSON - Example):**
    ```json
    {
      "errorCode": "AUTH_001",
      "message": "Invalid authentication code provided.",
      "timestamp": "2023-10-27T10:30:00Z"
    }
    ```

### 3. Call Hierarchy

The `AuthCallbackController.handleSsoCallback` method orchestrates the entire authentication process by invoking a series of internal services and operations.

1.  **`AuthCallbackController.handleSsoCallback(HttpServletRequest request, HttpServletResponse response)`**
    *   **Purpose:** The entry point for the SSO callback. It receives the HTTP request from the browser redirect and manages the overall flow.
    *   **Operations:**
        *   **Request Parameter Validation:** Initially validates the presence and basic format of critical query parameters like `code` and `state`.
        *   **Invokes `SsoCallbackService.processSsoCallback(request)`:** Delegates the core business logic of handling the SSO response to a dedicated service.
        *   **Sets Authorization Header:** Upon successful processing by the service, it extracts the generated internal JWT and sets it in the `Authorization` header of the `HttpServletResponse`.
        *   **Adds Session Cookies:** Adds the `SESSIONID` and `XSRF-TOKEN` cookies (generated by `SessionCookieService`) to the `HttpServletResponse`.
        *   **Returns `ResponseEntity<AuthSuccessResponse>`:** Constructs and returns the final JSON success response to the client.

2.  **`SsoCallbackService.processSsoCallback(request)`**
    *   **Purpose:** Encapsulates the complex logic required to transform an external SSO authentication into an internal application session.
    *   **Operations:**
        *   **Calls `OAuth2Service.exchangeCodeForTokens(code)`:**
            *   **Role:** Responsible for communicating with the external SSO provider's token endpoint.
            *   **Input:** The authorization `code` obtained from the initial callback.
            *   **Output:** Returns a bundle of external tokens (e.g., `access_token`, `refresh_token`, `id_token`) received from the SSO provider.
            *   **Details:** This involves making an HTTP POST request to the external OAuth2 provider's token endpoint, typically requiring client credentials (client ID, client secret) and the redirect URI.
        *   **Calls `JwtService.createInternalJwt(userId, roles)`:**
            *   **Role:** Generates the application's internal, secure JWT.
            *   **Input:** Extracts `userId` and `roles` by securely validating the `id_token` obtained from the external SSO provider. This validation ensures the `id_token` is signed correctly by the SSO provider and has not expired.
            *   **Output:** Returns the signed internal JWT string.
            *   **Details:** The JWT is signed using the application's private key and configured with an appropriate expiration time (e.g., 15 minutes), as well as claims such as `userId` and `roles`.
        *   **Calls `SessionCookieService.createSessionCookies(internalJwt)`:**
            *   **Role:** Responsible for creating the secure session cookies.
            *   **Input:** The `internalJwt` string.
            *   **Output:** Configures the `HttpServletResponse` with the `SESSIONID` and `XSRF-TOKEN` cookies.
            *   **Details:** This method sets various security attributes on the cookies (e.g., `HttpOnly`, `Secure`, `SameSite=Lax`) and defines their expiration periods (e.g., `SESSIONID` for 30 days, `XSRF-TOKEN` for the current session or short-term).
        *   **Calls `UserService.updateLastLogin(userId)`:**
            *   **Role:** Updates the user's last login timestamp in the database.
            *   **Input:** The `userId` of the authenticated user.
            *   **Output:** None (performs a database write operation).
            *   **Details:** Ensures that the user's activity is tracked for auditing and reporting purposes.

### 4. Key Operations

The following are the primary operations performed by this endpoint:

*   **Request Validation:** Ensures that the incoming callback request contains all necessary parameters (`code`, `state`) and that the `state` parameter matches the one originally sent, preventing CSRF attacks during the OAuth2 flow.
*   **External Token Exchange:** Initiates a secure, server-to-server communication with the external SSO provider to exchange the temporary authorization `code` for long-lived access tokens and an ID Token.
*   **Internal JWT Generation:** Creates a JSON Web Token that represents the user's authenticated session within our application. This token is cryptographically signed and contains essential user information (e.g., user ID, roles) and an expiration time.
*   **ID Token Validation:** If an `id_token` is provided by the external SSO provider, it is meticulously validated (signature, issuer, audience, expiration) to ensure its authenticity and integrity before user details are extracted.
*   **Secure Cookie Management:** Generates and sets secure HTTP cookies (`SESSIONID`, `XSRF-TOKEN`) in the user's browser, which are critical for maintaining session state and enhancing security against CSRF attacks.
*   **User Last Login Update:** Records the timestamp of the user's successful login in the application's user database, useful for auditing and analytics.

### 5. Dependencies

This endpoint relies on several components, services, and data structures to function correctly:

*   **Request/Response Entities (DTOs/Models):**
    *   `HttpServletRequest`, `HttpServletResponse`: Core Java Servlet API objects for handling HTTP requests and responses.
    *   `AuthSuccessResponse`: A Data Transfer Object (DTO) defining the structure of the successful JSON response payload.
    *   `ExternalOAuthTokens`: An internal model or DTO to hold the tokens (e.g., `access_token`, `refresh_token`, `id_token`) received from the external SSO provider.
    *   `JwtPayload`: An internal structure representing the claims (data) contained within the application's internal JWT.
*   **Services/Libraries:**
    *   `SsoCallbackService`: The primary business logic orchestrator for SSO callbacks.
    *   `OAuth2Service`: Handles communication with external OAuth2/OpenID Connect providers (e.g., exchanging codes for tokens).
    *   `JwtService`: Responsible for generating, signing, and potentially validating internal JWTs. Likely uses a dedicated JWT library (e.g., `jjwt` for Java).
    *   `SessionCookieService`: Manages the creation and secure configuration of HTTP cookies.
    *   `UserService`: Interacts with the user database to retrieve or update user information.
    *   **HTTP Client Library:** (e.g., Spring's `RestTemplate` or `WebClient`) for making outgoing calls to the external SSO provider.
*   **Database Entities/Tables:**
    *   `users` table: Stores user profiles and is updated with `lastLogin` timestamp.
*   **Frameworks/Utilities:**
    *   Spring Framework (Spring Boot, Spring Web): Provides the foundational structure for controllers, services, and dependency injection.
    *   Spring Security: Likely used for managing `HttpServletRequest`/`Response` and possibly for integrated security features like CSRF token handling.
    *   Logging Utility (e.g., SLF4J/Logback): For recording operational information and errors.

### 6. Security Features

The endpoint incorporates robust security measures to protect user data and maintain application integrity:

*   **JWT Security:**
    *   **Signed JWTs (JWS):** The internal JWT is cryptographically signed using a strong algorithm (e.g., HS256, RS256) and the application's private key, ensuring its integrity and authenticity.
    *   **Expiration:** JWTs are issued with a limited lifespan (e.g., 15 minutes) to mitigate the risk of token misuse if intercepted.
    *   **Claims:** JWTs contain minimal, necessary claims (e.g., `userId`, `roles`) to reduce token size and potential exposure.
*   **Cookie Security:**
    *   **`HttpOnly` Flag:** The `SESSIONID` cookie is marked `HttpOnly`, preventing client-side JavaScript from accessing it, thereby mitigating XSS (Cross-Site Scripting) attacks.
    *   **`Secure` Flag:** Both `SESSIONID` and `XSRF-TOKEN` cookies are marked `Secure`, ensuring they are only sent over encrypted HTTPS connections, protecting against eavesdropping.
    *   **`SameSite=Lax` Policy:** The `SESSIONID` cookie uses `SameSite=Lax`, providing significant protection against CSRF (Cross-Site Request Forgery) attacks by limiting when the browser sends the cookie with cross-site requests.
    *   **Expiration (`Max-Age`):** Cookies are issued with appropriate expiration times, balancing security with user convenience.
*   **State Parameter (OAuth2):** The `state` parameter in the OAuth2 callback flow is crucial for CSRF protection. The application verifies that the received `state` matches the one it originally sent to the SSO provider.
*   **Input Validation:** All incoming query parameters (`code`, `state`) are validated to prevent malicious input or unexpected formats.
*   **CORS (Cross-Origin Resource Sharing):** It's assumed that CORS policies are appropriately configured at the application level (e.g., via Spring Security or a dedicated CORS filter) to control which origins are permitted to make requests to this endpoint.

### 7. Error Handling

Error handling is critical for providing a robust and reliable API.

*   **Types of Errors Handled:**
    *   **Invalid Input/Parameters:** Missing or malformed query parameters (`code`, `state`).
    *   **Authentication Failures:** When the external SSO provider rejects the token exchange, the `id_token` is invalid, or the `state` parameter doesn't match.
    *   **External Service Failures:** Issues communicating with the external SSO provider (e.g., network timeout, provider's endpoint down).
    *   **Internal Service Errors:** Failures within our application's services (e.g., database connection issues, JWT signing key problems, unexpected null pointers).
*   **Error Management:**
    *   **Logging:** All errors, especially internal server errors and authentication failures, are logged with sufficient detail (e.g., error type, relevant parameters, stack traces) to aid in debugging and monitoring. Sensitive information is masked.
    *   **Exception Handling:** Exceptions are caught at appropriate levels (e.g., service layer, controller advice) and translated into client-friendly error responses.
    *   **Client Response:** Errors are returned to the client with appropriate HTTP status codes (`400`, `401`, `500`) and a standardized JSON error payload, providing a clear error `message` and `errorCode` without exposing sensitive internal details.
*   **Graceful Degradation:** While not explicitly detailed, ideally, external service failures would be handled in a way that prevents cascading failures, possibly through retries or circuit breakers for the `OAuth2Service`.

### 8. Performance Considerations

The endpoint's design considers performance to ensure a smooth user experience.

*   **External Call Latency:** The most significant performance factor is the round-trip time to the external SSO provider (`OAuth2Service.exchangeCodeForTokens`). This is an external dependency, and its latency directly impacts the overall response time. Metrics would typically track this.
*   **Efficient Token Generation:** JWT generation and signing are cryptographic operations that are generally optimized by libraries. The process is stateless and doesn't involve heavy database lookups per request, making it efficient.
*   **Minimal Database Operations:** Only a single, lightweight database update (`UserService.updateLastLogin`) is performed per request, minimizing database contention.
*   **Cookie Optimization:** Cookies are kept as small as possible to reduce network overhead on subsequent requests.
*   **Metrics Collection:** The system is typically instrumented to collect metrics on response times, error rates, and external service call latencies, enabling performance monitoring and bottleneck identification.

### 9. Usage Pattern

This endpoint is a crucial component of the user authentication flow, specifically for users leveraging external SSO.

*   **Typical Use Case:**
    1.  A user attempts to log into our application using an "Authenticate with Google" (or similar) button.
    2.  The application redirects the user's browser to the external SSO provider's authorization page (along with a generated `state` parameter and `redirect_uri` pointing to this endpoint).
    3.  The user successfully authenticates with the SSO provider.
    4.  The SSO provider redirects the user's browser back to this `/api/v1/auth/callback/sso` endpoint, including the `code` and `state` parameters in the URL.
    5.  This endpoint processes the callback, establishes the internal session, and returns the application-specific JWT and cookies to the client.
    6.  The client-side application then uses the received JWT and cookies for all subsequent authenticated API calls to our backend.
*   **Prerequisites:**
    *   The application must be registered as a client with the external SSO provider, possessing a Client ID and Client Secret.
    *   The `redirect_uri` configured with the external SSO provider must precisely match this endpoint's URL.
    *   The user must have successfully authenticated with the external SSO provider before being redirected to this callback.

### 10. Additional Notes

*   **Configuration:** The endpoint's behavior is heavily dependent on configuration details for the external SSO provider, including its authorization and token endpoints, client credentials, and allowed scopes. These are typically managed through application configuration files or environment variables.
*   **Token Revocation:** This endpoint *issues* authentication tokens. A separate mechanism (e.g., a logout endpoint) would be required to explicitly revoke an internal JWT or invalidate a session before its natural expiration.
*   **Scalability:** The use of stateless JWTs for authentication significantly contributes to the scalability of the backend, as session information doesn't need to be stored on the server for every authenticated request after the initial login.